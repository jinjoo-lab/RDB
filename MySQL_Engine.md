# MySQL 아키텍처 (MySQL 엔진)

## MySQL 아키텍처

![Untitled](https://user-images.githubusercontent.com/84346055/272872069-7e16e00c-f4e9-4f00-a1ad-db85c925fdb7.png)

## MySQL 서버

- **MySQL 엔진**
- **스토리지 엔진**

> 스토리지 엔진은 **핸들러 API를 만족하게 직접 구현하여 MySQL 서버에 추가**할 수 있다. 가장 많이 사용하는 스토리지 엔진으로는 InnoDB , MyISAM이 있다.
>
- MySQL 엔진은 MySQL 서버 당 한개지만 스토리지 엔진은 여러개가 존재할 수 있다.

### MySQL 엔진

> 클라이언트로부터 접속 , 쿼리 요청 처리 + 쿼리 실행 최적화(옵티마이저)
>
1. 커넥션 핸들러 (커넥션 풀)
2. SQL 파서 + 전처리기
3. 옵티마이저

### 스토리지 엔진

> 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 기능 담당
>
- 테이블 마다 스토리지 엔진을 다르게 설정할 수 있다.

```sql
CREATE TABLE test_table (fd1 INT , fd2 INT) ENGINE=INNODB;
```

### 핸들러 API

- 핸들러 요청
    - MySQL 엔진의 쿼리 실행기 → 데이터를 쓰거나 읽을 때 **스토리지 엔진에 보내는 요청**
    - 요청들에 대한 API : 핸들러 API
- 핸들러 API를 직접 구현한다면 MySQL과 통신할 수 있는 사용자 정의 스토리지 엔진인 것이다.

---

## MySQL 스레딩

### 구조

![Untitled](https://user-images.githubusercontent.com/84346055/272872091-04bbf86b-3c15-4bc4-94ff-7d791be519e8.png)

- MySQL 서버는 프로세스 기반이 아니라 **스레드 기반**으로 동작
    - **포그라운드**(Foreground) 스레드
    - **백그라운드**(Background) 스레드
- **스레드 모델**

  MySQL 커뮤니티 에디션 : **전통적인 스레드 모델**

    - 커넥션 : 포그라운드 스레드 ( 1 : 1 )

  MySQL 엔터프라이즈 에디션 , Percona : **스레드 풀 모델**

    - 커넥션 : 포그라운드 스레드 ( N : 1 )

### 포그라운드 스레드(클라이언트 스레드)

> 포그라운드 스레드 : 최소 MySQL 서버에 접속한 클라이언트 수
>
- 클라이언트가 요청하는 **쿼리 문장 처리**
    - 데이터를 버퍼나 캐시로부터 가져온다.
    - 직접 디스크나 인덱스 파일에 접근하여 데이터를 읽어온다.
- 클라이언트의 작업이 끝나 커넥션 종료 시 → 스레드 캐시로 되돌아간다.
    - 스레드 캐시 내부에는 일정 수의 스레드만 존재하도록 유지 : **thread_cache_size**
- **InnoDB VS MyISAM**
    - MyISAM : 디스크 쓰기 작업 → 포그라운드 스레드가 처리
    - **InnoDB : 데이터 버퍼 , 캐시까지만 포그라운드 스레드 범위 , 버퍼 → 디스크  작업 : 백그라운드**

### 백그라운드 스레드

- 지연 쓰기를 지원한다.
- (InnoDB와 관련)
    1. Insert Buffer를 병합하는 스레드
    2. **로그 → 디스크 기록 스레드**
    3. **InnoDB 버퍼 풀의 데이터 → 디스크 기록 스레드**
    4. 디스크 데이터 → 버퍼로 읽어오는 스레드
    5. 락 + 데드락 모니터링 스레드
- **데이터 쓰기 작업 VS 읽기 작업**

  데이터 쓰기 작업은 버퍼링이 허용될 수 있다.

    - InnoDB 에서는 I**NSERT, UPDATE, DELETE** 쿼리로 데이터가 변경 되는 경우 → 데이터가 디스크 파일에 도달할 때까지 기다리지 않아도 된다.

---

## MySQL 메모리

### 구조

![Untitled](https://user-images.githubusercontent.com/84346055/272872095-0a43531a-b1c4-48e0-97a9-6a97346a0a8c.png)

### 메모리 영역

- 글로벌 메모리 영역
    - MySQL 서버가 시작되면서 **운영체제로부터 할당**받음
    - 스레드의 수와 무관하게 독립적인 메모리 공간 (**모든 스레드가 공유**)
        - 테이블 개시
        - InnoDB 버퍼 풀
        - InnoDB 어댑티브 해시 인덱스
        - InnoDB 리두 로그 버퍼
- 로컬(세션 , 커넥션) 메모리 영역
    - **클라이언트 스레드가 쿼리를 처리**하는데 사용하는 메모리 영역
    - 각 클라이언트 스레드 별로 독립적 할당 , **공유되지 않는다.**
    - 쿼리 실행 순간만 할당 (이후 해제)
        - 정렬 버퍼
        - 조인 버퍼
    - 커넥션이 연결된 동안 유지
        - 네트워크(커넥션) 버퍼
        - 바이너리 로그 버퍼

## 스토리지 엔진

### 플러그인

- MySQL의 독특한 구조 : **플러그인 모델**
    - 스토리지 엔진
    - 검색어 파서(인덱싱할 키워드 분리 작업)
    - 사용자 인증 처리 모델

![Untitled](https://user-images.githubusercontent.com/84346055/272872098-11f30644-2362-4042-aea0-63f6aeba807b.png)

- **플러그인 모델 사용 가능 이유**
    - 쿼리 수행 과정에 있어 스토리지 엔진은 실질적으로 **데이터 읽기 / 쓰기 작업만 수행**하기 때문이다. (처리 범위가 좁다)
    - MySQL엔진은 핸들러를 통해 스토리지 엔진에 접근 → Handler를 바꾼다면 스토리지 엔진도 바뀔 수 있다 !
        - 즉 실질적인 **SQL을 해석하고 명령을 내리는 것은 MySQL 엔진의 영역**이기 때문에 스토리지 엔진을 플러그인을 통해 사용할 수 있는 것이다.

### 컴포넌트

- MySQL 8.0부터는 **컴포넌트 아키텍처** 지원

### **플러그인 아키텍처 단점**

1. 플러그인은 오직 MySQL 서버와 인터페이스 가능 , **플러그인끼리는 통신 불가능**
2. 플러그인은 **캡슐화 불가능** ( MySQL 서버의 변수 , 함수를 직접 호출 )
3. 플러그인은 상호 의존 관계 설정 X → 초기화가 어렵다.

### 컴포넌트 아키텍처 특징

1. 기능을 확장하기 위해 실행 중인 서버에 추가 구성 component를 추가할 수 있으며 **component는 동적으로 또는 정적으로 연결**할 수 있습니다.
2. component 는 다른 component 가 사용할 수 있는 광범위한 명명된 API 와 서비스의 구현을 제공합니다.
3. component는 **서비스 API를 통해 다른 구성 component와 통신**할 수 있으며, 그리고 다른 component가 사용할 서비스 API 구현을 제공

[MySQL 8.0 - Components 와 Plugin - 컴포넌트 - 플러그인 - MySQL 8.0 신기능](https://hoing.io/archives/1070)

---

## 쿼리 실행 구조

### 도식화

![Untitled](https://user-images.githubusercontent.com/84346055/272872099-5d520a61-71e5-4f4b-97d5-e1d934c36dde.png)

```yaml
1. 클라이언트 요청
2. 쿼리 파서
3. 전처리기
4. 옵티마이저
5. 쿼리 실행기
6. 스토리지 Engine
7. 클라이언트로 결과 반환

클라이언트 <-> MySQL Engine(2 ~ 5) <-> 스토리지 Engine(6)
```

1. **쿼리 파서**
    - 쿼리 문장을 **토큰 단위로 분리하여 트리 형태의 구조**로 만들어 내는 작업 → 파서 트리 생성
    - 쿼리 **문법적 오류 검출**
2. **전처리기**
    - 파서 트리에서 구조적 문제점 확인
        - **객체의 존재 여부와 접근 권한 확인**
3. **옵티마이저**
    - **쿼리 문장을 최소 비용에 최소 시간으로 처리 결정**
        - 쿼리 변환
        - 비용 최적화
        - 실행 계획 수립
4. **쿼리 실행기**
    - 만들어진 계획으로 실행 (핸들러와 요청을 주고 받음)
    - 쿼리 실행기는 **스토리지로부터 받은 결과를 사용자에게 전달**
5. **스토리지 엔진**
    - 실제 데이터 읽기 / 쓰기 수행

---

### 쿼리 캐시

- 쿼리 수행 결과 → 메모리에 캐시 , 동일한 쿼리 수행 시 즉시 결과 반환
- **MySQL 8.0부터는 지원하지 않는다 !**
    - 테이블의 데이터가 변경되면 캐시에 저장된 결과 중 변경된 것을 삭제
    - 동시 처리 성능 저하 (읽기만 하는 서비스는 없다 !)

### 스레드 풀

- MySQL 커뮤니티 에디션 → 제공하지 않는다.
- 기본 원칙 : **1개의 스레드로 여러 개의 커넥션 처리**

> 사용자의 요청을 처리하는 스레드의 개수를 줄여 동시 처리 요청이 많아도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중 (서버의 자원 소모를 줄이는 것)
>
