# Transaction

## RDB

### 트랜잭션

- 하나 이상의 DB 접근 연산을 포함하는 **DB 처리의 논리적 단위**
- 목적
    - 동시성 제어
        - 동시에 수행되는 트랜잭션들이 DB에 미치는 영향이 이들을 순차적으로 수행했을 때와 동일해야 함.
        - 일관성이란 → All or Not (전부 처리되거나 전부 처리되지 않거나)
    - 회복 (recovery)
        - 데이터베이스 갱신 과정에서의 오류에도 데이터베이스는 일관성을 유지

### ACID

**A** : **원자성(Atomicity)**

- All or Nothing : 한 트랜잭션 내의 모든 연산들이 **전부 수행**되거나 **전부 수행되지 않거나**
- DBMS 회복 모듈
    - 부분적으로 갱신한 트랜잭션 : 영향을 취소
    - 완료된 트랜잭션 : 트랜잭션의 영향을 재수행

**C : 일관성(Consistency)**

- 트랜잭션이 수행되기 전에 일관된 상태 → 트랜잭션이 수행된 후에는 또 다른 일관된 상태를 가진다

**I : 고립성(Isolation)**

- 한 트랜잭션이 데이터를 갱신하는 동안 갱신 중인 **데이터를 다른 트랜잭션이 접근하지 못하도록** 해야함
    - 다수의 트랜잭션이 동시 수행 → 순서에 상관없이 하나씩 수행한 결과와 동일
- DBMS 동시성 제어 모듈
    - 트랜잭션의 고립성 보장
    - 고립 수준 (Isolation Level)

**D : 지속성(Durability)**

- 완료된 트랜잭션의 효과는 시스템이 고장나더라도 데이터베이스에 반영되어야한다.
- DBMS의 회복 모듈

| 트랜잭션 특성 | DBMS 기능 |
| --- | --- |
| 원자성 | 회복 |
| 일관성 | 무결성 제약조건, 동시성 제어 |
| 고립성 | 동시성 제어 |
| 지속성 | 회복 |

Commit ( 트랜잭션 완료 )

- **COMMIT**
    - 트랜잭션의 수행 내용이 데이터베이스에 반영됨

Abort ( 트랜잭션 철회)

- **ROLLBACK**
    - 트랜잭션의 변경 내용이 일부만 수행된 경우 원자성 보장을 위해 트랜잭션 수행 전 상태로 되돌림

### 동시성 제어

- DBMS는 다수 사용자가 접근한다.
- 트랜잭션들 간의 간섭이 생기지 않도록 하는 것 !

**스케줄**

- 직렬 스케줄
    - 트랜잭션의 집합을 차례대로 수행
- 비직렬 스케줄
    - 여러 트랜잭션들 동시에 수행
- 직렬 가능 스케줄
    - 비직렬 스케줄 결과 = 직렬 스케줄 결과

**동시성 제어를 하지 않을 경우 발생 문제**

1. 갱신 손실 (lost update)
    - 수행 중인 **트랜잭션이 갱신한 내용을 다른 트랜잭션이 갱신** ( 갱신이 무효화 )
2. 오손 데이터 읽기 (dirty read)
    - **완료되지 않은 트랜잭션이 갱신한 데이터**를 읽는 것
3. 반복 불가 읽기 (unrepeatable read)
    - 한 트랜잭션이 **동일한 데이터를 두 번 읽을 때  서로 다른 값을 읽는 것**

**갱신 손실 (EX)**

![Alt text](https://user-images.githubusercontent.com/84346055/248883733-ee2a0f8e-74e6-45e5-bbce-c952debeae12.png)

- 직렬 스케줄의 경우 X = 250000 , Y = 700000

  T1 의 결과가 반영되기 전에 T2가 덮어쓰기


**Dirty Read (EX)**

![Alt text](https://user-images.githubusercontent.com/84346055/248883790-a0d110de-7efc-4ca8-9bf4-8a98590b3750.png)

- T1은 ROLLBACK 되었지만 T2의 AVG는 ROLLBACK 되기 이전의 값을 가지고 있다.

**Unrepeatable Read (EX)**

![Alt text](https://user-images.githubusercontent.com/84346055/248883820-9103ed2e-5006-4d3e-9fd1-cd0aae0d0782.png)

- T2의 두번의 SELECT 연산의 결과가 다르다 !

## Lock

- 트랜잭션의 동시성 제어에 가장 많이 사용되는 개념
- lock : 데이터 베이스내의 각 데이터 항목과 연관되어 존재하는 변수
    - Lock table에서 유지
    - 접근이 끝난 경우 unlock

### Lock 범위

- 데이터베이스, 파일, 테이블, 로우, 칼럼
- 락의 범위가 작을수록 오버헤드 증가 , 동시성 정도 증가

### Lock 종류

- **독점(배타) 락( X - lock , Exclusive lock )**
    - 트랜잭션에서 **갱신**을 목적으로 데이터 항목에 접근시 요청
    - 독점 락은 양립 불가능 말 그대로 독점적
- **공유 락 ( S - lcok , Shared lock )**
    - 트랜잭션에서 **읽을** 목적으로 데이터 항목에 접근시 요청
    - 공유 락끼리는 양립 가능
- 독점 락과 공유 락은 read 연산에 락을 거는가 아닌가에 차이로 요약 가능

**Lock 양립성 행렬**

![Alt text](https://user-images.githubusercontent.com/84346055/248883877-42614631-4512-49f7-b8a3-98c62100b2f8.png)

**2PL(2-phase locking) Protocol**

- Lock 확장 단계
    - 새로운 Lock을 요청만 가능 (트랜잭션에서 필요한 모든 Lock을 걸었을 때 → Lock Point)
- Lock 수축 단계
    - 진행중이던 Lock을 해제만 가능 (기존의 Lock을 하나라도 해제하면 수축 단계로 진입)

**static 2PL**

- 데드락이 발생하지 않는 프로토콜
- 트랜잭션이 접근하려는 **모든 항목의 락을 획득 후** 수행

**strict 2PL**

- 가장 많이 사용되는 프로토콜
- 트랜잭션 COMMIT , ROLLBACK 전까지 **배타 락을 해제하지 않는다.**

**rigorous 2PL**

- 트랜잭션 COMMIT , ROLLBACK 전까지 **모든 락을 해제하지 않는다.**

### 데드락 (Dead Lock) - 교착상태

- 두 개 이상의 트랜잭션들이 서로 상대방이 보유한 락을 요청하면서 대기하는 상태

![Alt text](https://user-images.githubusercontent.com/84346055/248883887-b9a5f5d2-d191-498f-bd7f-3a96e1ceb4be.png)

- 위 그림에서 T1은 Y에 대한 락을 보유 , T2는 X에 대한 락을 보유 (서로가 반대된 락을 요청)

### 데드락 해결 방법

- 데드락 방지 프로토콜
    - static 2PL

**교착상태 방지 기법**

- wait - die 알고리즘
    - 비선점 기법
    - T1에 락된 데이터
        - T2가 타임스탬프가 더 빠르다면 : Wait
        - T2가 타임스탬프가 더 느리다면 : Die (포기)
- wound - wait 알고리즘
    - 선점 기법
    - T1에 락된 데이터
        - T2가 타임스탬프가 더 빠르다면 : Wound (선점)
        - T2가 타임스탬프가 더 느리다면 : Wait

**교착상태 검출 기법 - ( Union - Find )**

- 대기 그래프 구성 → **사이클의 존재 유무**로 교착 상태 탐지 ( Union - Find )
- 교착상태는 철회할 **희생자 선택**하여 해결

**시간 초과 ( Timeout 설정 )**

- 트랜잭션이 정의한 시간보다 더 대기하는 경우 철회 ( 교착상태 발생 여부는 판단하지 않는다 )

### 팬텀 문제

- 한 트랜잭션 내에서 같은 쿼리 두번 실행 → **첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는** 현상

![Alt text](https://user-images.githubusercontent.com/84346055/248883978-4dc9dab4-2c8b-40c6-ae6c-c4e5ff719a33.png)

- T1에서 동일한 쿼리를 두번 수행 → 없던 ‘정희연’의 데이터가 두번째 쿼리에서 나타날 것이다.

## 회복(Recovery)

- 원자성과 지속성을 위해서 필요한 작업
    - 지속성 : REDO(재수행)
    - 원자성 : UNDO(취소)

### 로그를 사용한 즉시 갱신

**로그**

- 트랜잭션의 원자성과 지속성을 유지하기 위한 DBMS 내 파일 형태
- 트랜잭션 연산들에 대해 로그 레코드를 기록
    - 로그 순서 번호(LSN)로 식별된다.
    - 동일한 트랜잭션에 대한 로그 레코드(트랜잭션 ID를 포함)들은 연결 리스트로 유지

**Commit Point**

- DBMS 회복 모듈은 로그를 검사
    - start , commit 로그 레코드가 모두 존재하는 트랜잭션 재수행

![Alt text](https://user-images.githubusercontent.com/84346055/248884002-2ca8d009-ca2c-4fc2-9ca4-08fc4799ea01.png)

### Shadow Paging( 그림자 페이징 )

- 로그를 이용하지 않고 트랜잭션 수행하는 동안 현재 페이지 테이블과 그림자 페이지 테이블을 유지하는 것

**과정**

- 트랜잭션이 시작 : 현재 테이블을 **그림자 테이블에 복사**
- 트랜잭션 수행 : 현재 테이블에 변경 적용
- 트랜잭션 종료 : 현재 테이블의 내용을 그림자 테이블에 갱신

**회복 동작**

- 장애 발생 시 그림자 페이지 테이블을 메인 메모리에 복사해 트랜잭션 재실행

특징

- 단일 사용자 환경에서 로그 불필요
- 다중사용자 환경에서는 사용하기 어렵다
    - **동시성 제어**
        - 동시에 실행되는 다른 트랜잭션들이 그림자 페이지에 접근하여 일관성을 유지하기 어렵다

**장점**

- 복구 속도가 빠르다.

**단점**

- **클러스터링**이 어렵다.
    - 갱신된 페이지들의 디스크 상 위치가 변하기 때문
- 디렉토리나 테이블의 크기가 큰 경우 **오버헤드**

### 체크포인트

- 체크포인트 시점에 주기억 장치 버퍼 내용이 디스크에 강제 기록
    - 이미 완료된 트랜잭션의 불필요한 재실행을 방지

### 종합 비교

![Alt text](https://user-images.githubusercontent.com/84346055/248884018-0d5123f2-8581-438e-8760-db2bbb04c7ea.png)

출처 : [https://itpenote.tistory.com/629](https://itpenote.tistory.com/629)

### **ARIES 회복 알고리즘**

**단계**

- 분석 단계
    - REDO(재실행)이 시작되어야 하는 로그 위치 결정
- REDO 단계
    - 해당 시점부터 트랜잭션 재실행
- UNDO 단계
    - 로그를 역순을 읽으면서 진행 트랜잭션의 연산을 취소

**필요 정보**

- 로그
- 트랜잭션 테이블
- 오손 페이지 테이블

![Alt text](https://user-images.githubusercontent.com/84346055/248884034-0643593e-2c0f-47d2-aac2-f4c85d474186.png)

## 고립 수준

- 트랜잭션들끼리 **일관된 데이터를 얼마나 허용**할 지 정하는 수준
- 고립수준 낮으면 동시성은 높아지지만 데이터 정확성은 떨어짐

**트랜잭션의 격리(고립) 수준**

트랜잭션간 충돌을 이야기 하기전 충돌이 일어나는 근본적인 이유를 알아보자. 기본적으로 충돌이 일어나는 원인은 고립 수준이 낮기 때문에 발생하는 것이다.

전통적으로 데이터베이스(ANSI SQL 기준)에서는 트랜잭션의 고립 수준을 다음 4가지로 나눈다.

- Serializable
- Read Repeatable (Repeatable Read)
- Read Commited
- Read Uncommited

- **Serializable (Level 3)**
    - 고립 수준이 가장 높다.
    - 트랜잭션 동시 실행 X
    - 모든 접근에 대해 베타적인 Lock이 걸리고, 마치 Queue와 같이 순차적으로 실행되는 것처럼 보인다.

- **Read Repeatable  (Level 2)**
    - 트랜잭션이 시작되기 전 커밋된 내용만 조회한다.
    - 트랜잭션 완료시까지 모든 데이터에 대해 Shared Lock이 걸린다.
    - `Phantom Read` 가 발생할 수 있다.

- **Read Commited  (Level 1)**
    - 트랜잭션 중 변경 내용만 커밋된 것을 조회한다.
    - `Non-repeatable Read` 가 발생할 수 있다.

- **Read Uncommited  (Level 0)**
    - 고립 수준이 가장 낮다.
    - 트랜잭션과 관계없이 모든 조회할 수 있다.
    - `Dirty Read` 가 발생할 수 있다.

> 참고로, RDB 중 MySQL은 **Read Commited,** PostgreSQL은 **Read Repeatable** 을 기본 고립 수준으로 갖는다.
>

**읽기 정합성 문제 (Read Skew)**

- `Phantom Read`
    - 한 트랜잭션에서 같은 쿼리를 두번 날렸을 때 없던 결과가 조회되던 것
- `Non-repeatable Read`
    - 한 트랜잭션에서 같은 쿼리를 두번 날렸을 때 처음과 결과가 다르게 조회되는 것
- `Dirty Read`
    - 커밋되지 않은 트랜잭션의 내용을 읽는 것

![output.gif](https://user-images.githubusercontent.com/84346055/248884095-e92b73c5-795f-4f66-8b83-bfb7a4b74c1e.gif)
