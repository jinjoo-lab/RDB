# Index -1 (인덱스 자료구조 - Scan)

### Index

- 사전적 정의 : **색인**
    - 데이터를 효율적으로 조회하기 위해 사용하는 자료구조 (검색 성능을 향상)
    - 인덱스의 조건
        - 구별
            - 데이터 베이스에서 조회하기 위해서는 **데이터를 식별**할 수 있는 존재가 필요하다**(칼럼)**
        - 정렬
            - **정렬**을 통해 데이터를 효과적으로 탐색할 수 있고 데이터의 유무또한 판단하기 쉽다.

> 인덱스란 데이터의 조회(SELECT)의 성능을 높이기 위한 자료구조이며 해당 레코드를 식별할 수 있는 기준이 되며 **정렬된 상태를 유지**한다.
>
- **장점**
    - 데이터의 조회(SELECT)의 속도가 빠르다 (성능이 좋다)
        - 서비스의 종류에 따라 검색의 비율이 절대적으로 많은 경우가 있다.
- **단점**
    - 인덱스 관리를 위한 **추가적인 저장공간**을 필요로 한다.
        - 인덱스 또한 데이터베이스의 객체이다. (저장이 필요하다)
    - 인덱스를 사용할 경우 **삽입, 수정, 삭제**의 성능이 떨어진다. (추가적인 연산 비용을 필요로 한다.)
- **삽입 , 수정 , 삭제**

  핵심은 **정렬**이다. 효율적인 탐색을 위해 데이터나 데이터 주소를 정렬해 놓을 경우 삽입 , 수정 , 삭제 시 데이터의 위치를 탐색해야 하기 때문에 속도가 떨어진다.

- **고찰**

  인덱스를 거치는 것은 거치지 않는 것보다 당연히 추가적 비용이 발생하는 작업이다.

  > 일반적인 DBMS 옵티마이저 → 인덱스를 통한 1건의 검색 = 인덱스를 통하지 않는 5건의 검색
  >
    - 인덱스를 통한 검색의 범위가 전체 테이블 레코드의 20 ~ 25 %라면 풀 테이블 스캔이 이득이라는 것
    - Why : 순차 I/O , Random I/O 의 차이

### 중복

> 인덱스가 중복이 가능한가 불가능한가에 따라 구분을 할 수 있다.
>
- PK
    - 데이터 베이스의 PK는 기본적으로 **중복이 불가능**하다. 그렇기 때문에 고유하게 식별할 수 있는 인덱스의 역할도 수행한다.
- 세컨더리 인덱스
    - PK를 제외한 모든 인덱스

### 인덱스 선택 기준

- 인덱스의 선택 기준
    - 카디널리티 (Cardinality)
        - 테이블에서 해당 데이터의 고유성을 나타내는 개념
        - 전체 데이터 개수(Row)에 대한 **특정 칼럼의 중복 수치**를 나타내는 지표
            - 중복도가 높으면 카디널리티는 낮다
        - 카디널리티는 테이블을 기준으로 **상대적인 평가**가 이루어진다.

    ```sql
    CREATE TABLE `used_car` (
      `license_number` VARCHAR(256), # 차량 등록 번호
      `price` int, # 가격
      `save_price` int, # 절감 가격
      `insurance_id` BINARY(16), # 보험 번호
      `created_at` timestamp,
      `updated_at` timestamp
    );
    ```

  > 중고차 테이블을 예시로 설명을 하자면 차량 등록 번호는 겹칠 수 없다. 이런 경우 **카디널리티가 높다**. (중복도가 낮다) 즉 인덱스로 사용하기 적합하다고 판단할 수 있다.
  >
    - 선택도 (Selectivity)
        - 선택도는 카디널리티를 기반으로 한 개념이다. **(카디널리티) / (전체 데이터의 개수)** 즉 비율이라고 생각하면 된다.
        - **선택도가 높을수록** 인덱스에 적합하다.

## 인덱스 자료구조

### HashTable

- Key - Value 형태로 데이터를 저장
    - 칼럼의 값으로 해시값 계산 → **Key(Index)**
- 굉장히 빠른 성능의 조회 속도를 가진다 → O(1)
- Equal 연산을 수행하는 경우에 유효하다. 그렇지 않은 경우 Full Scan
    - **범위 검색이 불가능**하다.
        - Index 값이 해싱 처리가 되었기 때문에 구간 탐색이 불가능하다.

### B-Tree

- **이진 탐색 트리**
    - 이진 탐색 트리란 자식 노드의 개수가 최대 2개이다.
    - 부모 노드를 기준으로
        - 왼쪽 서브 트리는 **키 값이 작은** 노드들
        - 오른쪽 서브 트리는 **키 값이 큰** 노드들
- **이진 탐색 트리의 단점**
    - 편향 트리일 경우 최악인 경우이며 시간 복잡도가 O(N)이다.
    - 쉽게 말하자면 특정한 경우에 트리의 구조가 불균형하다는 것이다.
- **B - Tree ( Balanced )**
    - **모든 리프 노드들이 같은 레벨을 가지는 트리**로서 DB 인덱스에서 사용하는 자료구조이다.
    - B - 트리는 이진 트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다. **최대 *M*개의 자식**을 가질 수 있는 B트리를 *M*차 B트리라 한다.
    - **범위 계산에 특화된 자료구조 !**
    - 항상 **정렬 상태를 유지**하고 있다.

![Untitled](https://user-images.githubusercontent.com/84346055/269582551-15900135-4b31-482e-9575-4f9068f154cb.png)

### B+ Tree

- MySQL 의 InnoDB에 사용되는 인덱스 자료구조
- 실제 **Data를 Leaf Node에만 저장**
    - 구조
        - **루트 노드 → 브랜치 노드 → 리프 노드**
        - B+ Tree 의 리프 노드들은 **더블 링크드 리스트로 연결**되어 있다.
- **Why ?**
    1. 하나의 블록에 더 많은 키를 저장할 수 있다.
        - 리프 노드를 제외하고는 데이터를 담아두지 않기 때문에 데이터를 더 확보할 수 있다.
        - 하나의 노드에 더 많은 키 저장 → 트리의 높이가 낮아짐
    2. (레인지)풀 스캔시 **B+Tree는 리프 노드에 데이터가 모두 있기 때문에 한번의 선형 탐색만 하면 되기 때문에 B-Tree 에 비해 빠르다.**
        - O(logN) + 선형 탐색

![Untitled](https://user-images.githubusercontent.com/84346055/269582582-03d26746-4343-4b18-b2ca-29e6e4feb18c.png)

## 인덱스 작업

### 인덱스 키 추가

- B - Tree 구조에 Key가 저장될때에는 저장될 키 값을 이용해 **적절한 위치 탐색**
    - 위치를 찾았다면 **레코드의 키 값**과 대상 **레코드의 주소 정보**를 리프 노드에 저장
    - 리프 노드가 전부 찼을 경우
        - Split ( 상위 브랜치 노드까지 처리의 범위가 확대된다. ) : 많은 비용 발생
            - 최악의 경우 root 노드까지 전파가 올라갈 수 있다.

![Untitled](https://user-images.githubusercontent.com/84346055/269582591-02cd2bff-00f6-429a-970f-8207b3045dc9.png)

### 인덱스 키 삭제

- 리프 노드 중 인덱스 키 값을 찾아서 삭제 마킹 처리
    - 마킹된 키 공간은 **재활용 가능**
    - 키 값이 가리키는 실제 데이터 레코드는 바로 삭제 처리가 되지 않는다.

### 인덱스 키 변경

- 키 값 → **저장될 리프 노드의 위치가 결정**된다.
    - 기존 Key 삭제 + 새로운 Key 추가 연산의 과정이 수행된다.
    - InnoDB 기준으로 Change Buffer 를 통해 지연 처리 가능

## 인덱스 키의 크기

- 페이지
    - **디스크와 메모리에 데이터를 읽고 쓰는 최소 단위 (페이지의 범위에 따라 디스크 I/O와 직결된다)**
    - 인덱스와 데이터 모두 데이터 베이스의 객체이기 때문에 페이지 단위로 관리한다.
- InnoDB 스토리지 엔진의 버퍼 풀
    - 데이터를 버퍼링하는 기본 단위 → 페이지
    - B - Tree 자료구조를 기준으로 노드 → 페이지 단위
- 인덱스를 구성하는 **키값의 크기가 커진다면?**
    - 디스크로부터 읽어야 하는 횟수가 증가하고 속도 측면에서 불리하다.

### B+ Tree의 깊이

- B+ Tree 의 깊이 → 데이터베이스 엔진에서 값을 검색할 때 몇번이나 랜덤 I/O (디스크에 접근)하는지와 관련
- 인덱스 페이지에 많은 인덱스를 담는 것이 랜덤 I/O를 줄일 수 있는 방법이다.

## Scan

### Full Table Scan

- 순차 접근
    - 원하는 데이터를 찾기 위해 **모든 데이터 요소를 순서대로 탐색**하는 방법 (선형 탐색)
    - 순차 I/O 를 사용한다.
- **Full Table Scan 사용 경우**
    1. 적용 가능한 인덱스가 없는 경우
    2. 인덱스의 처리 범위가 넓은 경우
        - **Full Table Scan > Index Range Scan**
    3. 크기가 작은 테이블(인덱스의 효과가 미비)인 경우

### Index Range Scan

- 검색해야 할 **인덱스 or 인덱스의 범위가 결정**되었을 때 사용하는 방식
    - 과정
        1. 인덱스 조건을 만족하는 값 탐색 ( 루트 → 브랜치 → 리프)
        2. 탐색 위치에서 필요한 만큼 인덱스를 읽는다 (레인지 스캔)
        3. 2번을 통해 인덱스 키와 레코드 주소를 이용해 페이지를 가져오고 (Random I/O) 최종적으로 레코드를 읽는다.


![Untitled](https://user-images.githubusercontent.com/84346055/269582595-6f3c2a0c-365d-404a-9426-3827d7d6c1a1.png)

- **데이터 파일 ?**

  ![Untitled](https://user-images.githubusercontent.com/84346055/269582598-21e00956-605b-4b61-a698-ef149447fffb.png)


### Index Full Scan

- 인덱스의 처음부터 끝까지 모두 읽는 방식
    - 쿼리의 조건절에서 다중 칼럼이 사용되는 경우 **인덱스의 첫 번째 칼럼이 아닌 경우**
    - 인덱스의 크기는 테이블의 크기보다 작으므로 인덱스에 명시된 칼럼으로만 쿼리 처리 가능 경우 사용

### Loose Index Scan

- 중간에 필요하지 않은 인덱스에 대해서는 SKIP하고 다음으로 넘어가는 형태
    - **Group By** **OR** **MIN() , MAX() 함수에 대해 최적화시 사용**

**ex)**

![Untitled](https://user-images.githubusercontent.com/84346055/269582602-4e942bd9-8387-415f-a56b-796792239c6e.png)

- 인덱스가 (dept_no , emp_no) 조합으로 정렬되어 있을 때 dept_no 그룹 별로 emp_no 레코드 값을 1개만 읽으면 된다.

## Multi -Column Index

- 다중 칼럼 인덱스
    - 인덱스의 키를 **두개 이상의 컬럼으로 구성**하는 경우

> 다중 칼럼 인덱스의 경우 2번째 컬럼은 1번째 컬럼에 의존하여 정렬되어 있다는 것. 복합 컬럼 인덱스 사용시 **컬럼의 순서가 중요**하다.
>

![Untitled](https://user-images.githubusercontent.com/84346055/269582604-3fe443f0-1792-49e3-92f1-3e975bd4d9e7.png)

- 정렬 순서를 혼합하여 복합 컬럼 인덱스 생성

![Untitled](https://user-images.githubusercontent.com/84346055/269582605-fb4bcd94-29b9-4cff-b307-7e701f051c54.png)

- 예시의 경우 team_name 을 기준으로는 **오름차순** , user_score을 기준으로 **내림차순**
- **정순(ASC) 스캔과 역순(DESC) 스캔의 차이**
    - InnoDB 스토리지 엔진 기준
        - 페이지 잠금이 정순에 유리한 구조
        - 페이지 내부에서 인덱스 레코드가 단방향으로 연결되어 있다. (Single Linked List)

## 참고

- Real -MySQL

[[MySQL 8.0] InnoDB 스토리지 엔진에서의 B+ Tree 인덱스를 통한 레코드 스캔 구조](https://velog.io/@msung99/MySQL-8.0-InnoDB-스토리지-엔진에서의-B-Tree-인덱스를-통한-레코드-데이터-스캔-최적화-구조)
