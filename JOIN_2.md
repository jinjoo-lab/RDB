# JOIN (수행 원리 + 최적화)

### Join

> 앞서 다양한 JOIN 연산과 해당 SQL 구문을 살펴봤다. 그렇다면 이러한 JOIN 연산은 어떻게 동작할까?
>
- 두 개 이상의 테이블을 하나의 집합으로 만드는 연산
- **같은 종류의 JOIN 쿼리라 해도 JOIN 기법에 따라 내부적으로 다르게 동작**하기 때문에 JOIN 연산의 수행 원리에 대한 이해가 필요하다 !

# Join 기법들 (수행 원리)

| 기법 | 설명 |
| --- | --- |
| Nested Loop Join (NL Join) | 선행 테이블에서 액세스한 각 값을 후행 테이블과 조인하는 방식 |
| Sort Merge Join (SM Join) | 조인 컬럼을 기준으로 데이터를 정렬하여 조인을 수행하는 방식 |
| Hash Join | 해시 함수를 이용해서 데이터를 조인하는 방식 |

## NL Join (Nested Loop Join)

- **중첩 for문**

```
IDOL_GROUP , IDOL_MEMBER를 예시로 설명 -> 테이블을 반복문으로 풀어보자

for(GROUP g : IDOL_GROUP){
	for(MEMBER m : IDOL_MEMBER){
			if(g.id == m.gId){
				// HIT !!!!
			}
	}
}
```

- 2개 이상의 테이블에서 **하나의 집합을 기준**으로 **순차적으로 상대방 Row를 결합**하여 원하는 결과를 만드는 조인 방식
    - **Driving Table(Outer Table)** : 선행 테이블 (먼저 액세스되어 Access Path를 주도하는 테이블)
        - Optimizer 가 결정
    - **Driven Table(Inner Table)** : 후행 테이블 ( 나중에 액세스되는 테이블)

### 동작 과정

![Untitled](https://user-images.githubusercontent.com/84346055/282753523-9554c892-eacc-45c1-9fef-98296130de6b.png)

- 프로그래밍에서 사용하는 중첩 반복문과 유사한 방식으로 조인 수행
- 반복문 외부의 테이블은 `선행 테이블` 혹은  `외부 테이블(Outer Table)` 이라 부른다.
- 반복문 내부에 있는 테이블은 `후행 테이블` 또는 ****`내부 테이블(Inner Table)` 이라 부른다.
- `선행 테이블` 의 조건을 만족하는 행을 추출하여 `후행 테이블`을 읽으면서 `조인`을 수행한다.
    - `선행 테이블`의 조건을 만족하는 모든 행의 수만큼 반복 수행
    - 결과행의 수가 적은 테이블을 선행 테이블로 선택하는 것이 좋다.

### 작업 방법

![Untitled](https://user-images.githubusercontent.com/84346055/282753552-d130c02b-56a4-49e4-a7ae-ad4defb4bf8a.png)

1. `선행 테이블`에서 주어진 조건을 만족하는 행을 찾는다.
2. `선행 테이블`의 조인 키 값을 가지고 `후행 테이블`에 [조인 키가 존재 확인 후 조인] 을 시도한다.
    1. [ ] 내부의 작업을 시도하러 간다.
3.  `후행 테이블` 의 `인덱스`에 선행 테이블의 조인 키가 존재하는지 확인한다.
    1. `선행 테이블`의 조인 값이 `후행 테이블`에 존재하지 않으면 `선행 테이블` 데이터는 필터링된다.
        1. 더 이상 조인 작업을 진행할 필요가 없다.
4. `인덱스`에서 추출된 레코드 식별자를 이용해 `후행 테이블`을 엑세스한다.
    1. `후행 테이블`에 주어진 조건이 모두 만족하면 해당 행을 추출버퍼에 넣는다.
5. 앞의 작업을 반복 수행한다.

### 특징

- **랜덤 엑세스 방식**으로 데이터를 읽는다. (인덱스 기반 검색)
    - 많은 I/O 가 발생할 수 있어 무조건 좋다고 볼 수는 없다.
- 조인이 성공하면 바로 조인 결과를 사용자에게 보여준다.
    - 최대한 빠르게 화면에 보여줘야 하는 온라인 프로그램에 적합한 조인 기법이다.
- 후행 테이블에 **인덱스가 존재**해야 효율적이다.
    - 효율적이라는 의미 : 인덱스가 없는 경우 매번 탐색에 FULL_SCAN !!!!
- 선행 테이블이 작고 처리 범위가 좁은 경우 효과적이다.

### 성능 개선

1. **선행 테이블을 적절히 선정**한다.
    - 데이터의 양이 상대적으로 적은 테이블이나 where절로 많이 거를 수 있는 테이블
    - View를 통해 테이블을 먼저 걸러내는 것도 좋은 선택지 !
2. **조인 조건으로 사용될 컬럼이 후행 테이블의 인덱스**로 걸려있는지 확인 !
    - FULL_TABLE_SCAN을 피하자

## SM Join (Sort Merge Join)

- 주로 스캔 방식으로 데이터를 읽는다.
- NL Join에서 부담이 되던 **넓은 범위의 데이터를 처리**할 때 이용되는 조인 기법이다.

> 양 쪽 테이블을 Access하여 결과를 **정렬**하고 정렬한 결과를 차례대로 **Sacn** , 조건으로 **Merge**하는 방식
>

### 동작 과정

1. 각 테이블에 대해 동시에 독립적으로 데이터를 읽어옴
    - 이 과정에서 index 조건이 있는 경우에는 index scan , 없는 경우에는 full scan
2. 읽어온 데이터들을 조인 조건에 따라 정렬한다.
3. 정렬이 모두 완료된 경우 조인 작업 수행

### 작업 방법

![Untitled](https://user-images.githubusercontent.com/84346055/282753542-8caf04c3-a2a7-4292-9f4a-0e0ae4e210f8.png)

1. `선행 테이블`에서 주어진 조건을 만족하는 행을 찾는다.
2. `선행 테이블`의 조인 키를 기준으로 정렬작업을 수행한다.
- 1 ~ 2번 작업을 `선행 테이블`의 조건을 만족하는 모든 행에 대해 반복 수행
1. `후행 테이블`에서 주어진 조건을 만족하는 행을 찾는다.
2. `후행 테이블`의 조인 키를 기준으로 정렬 작업을 수행한다.
- 3 ~ 4번 작업을 `후행 테이블`의 조건을 만족하는 모든 행에 대해 반복 수행
1. 정렬된 결과를 이용하여 조인을 수행한다.
2. 조인에 성공하면 추출버퍼에 넣는다.

### 특징

- Table Random Access가 일어나지 않는다.
- 인덱스가 없어도 사용 가능하다.
- 앞 단계의 작업에서 정렬작업이 미리 수행되어있으면, 정렬 작업이 다시 수행되지 않을 수 있다.
- 정렬할 데이터가 많아 메모리에서 모든 정렬 작업을 수행하기 어려운 경우에는 **임시 영역
  (디스크)을 사용**하기 때문에 성능이 떨어질 수 있다.
    - 대량의 조인 작업의 경우 CPU 위주의 작업을 수행하는 Hash Join이 성능상 유리하다.
- 동등 조인과 비동등 조인에 대한 작업도 가능하다.
    - 동등 조인
        - 동등한 값인지 비교하는 조인 (where절 에서 = 를 쓰는 방법)
    - 비동등 조인
        - 동등하지 않은 값인지 비교하는 조인 (where절 에서 <,>,≤,≥ 등을 사용하는 방법)

### 성능 개선

1. Table Access 속도 향상
2. 정렬 속도의 향상
3. SORT_AREA_SIZE 최적화

## Hash Join

- **해싱 기법을 이용하여 조인**을 수행한다.
- 조인될 두 테이블 중 **하나를 해시 테이블로 선정**하여 조인될 테이블의 조인 키 값을 Hash 알고리즘으로 비교하여 매치되는 결과값을 얻는 방식이다.
- HASH JOIN은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며 동등 조인에서만 사용될 수 있다.
- 주로 많은 양의 데이터를 조인해야 하는 경우에 주로 사용한다.

### 동작 과정

![Untitled](https://user-images.githubusercontent.com/84346055/282753555-a6af6a60-75e7-4479-a548-aa4f50eb6645.png)


1. 선행 테이블을 읽어 Hash Area에 **Hash Table 생성**
    - hash 함수의 리턴값인 버킷 주소의 해시 체인에 엔트리 연결
2. 후행 테이블을 읽어 Hash Table 탐색하여 JOIN

### 작업 방법

![Untitled](https://user-images.githubusercontent.com/84346055/282753548-cb76afc6-278c-4322-8ef0-92ef6c247866.png)

1. `선행 테이블`에서 주어진 조건을 만족하는 행을 찾는다.
2. `선행 테이블`의 조인 키를 기준으로 해시함수를 적용하여 해시 테이블을 생성한다.
- 1 ~ 2번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행한다.
1. `후행 테이블`에서 주어진 조건을 만족하는 행을 찾는다.
2. `후행 테이블`의 조인 키를 기준으로 해시 함수를 적용하여 해당 버킷을 찾는다.
3. 조인에 성공하면 추출버퍼에 넣는다.
- 3 ~ 5번 작업을 `후행 테이블`의 조건을 만족하는 모든 행에 대해 반복 수행한다.

### 특징

1. 조인 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 기법이다.
2. 메모리 사용이 큰 대용량 테이블 조인시 메모리 외에 임시영역(PGA 메모리)까지 사용하여 저장할 수 있어 유리하다.

### 성능 개선

1. 선행 테이블에서 조인 컬럼의 중복이 적게 만든다.
2. Hash 함수 최적화
3. PGA 메모리 영역 크기 최적화

## NL, SM, Hash Join의 공통점

- 모두 성공한 결과를 추출버퍼에 넣는다.
- 추출 버퍼는 SQL문의 실행 결과를 보관하는 버퍼로서, 일정 크기를 설정해 추출 버퍼에 결과가 모두 차거나 더 이상 결과가 없어서 추출 버퍼를 채울 것이 없으면 결과를 사용자에게 반환한다.
