# 데이터베이스 튜닝 (Replication)

# Replication

> 복제(Replication)
>
- **대용량 트래픽**에 대해 고려해야 하는 점
    - 확장성
    - 가용성 (DBMS 서버를 포함한 하위 시스템의 가용성)
- **Replication**
    - 하나의 서버에서 다른 서버로 데이터가 동기화 되는 것
        - **원본 데이터**를 가지고 있는 서버 : Master , **Source**
        - **복제된 데이터**를 가지고 있는 서버 : Slave, **Replica**

![Untitled](https://user-images.githubusercontent.com/84346055/284904379-95a30a06-1970-42b2-b169-085e88ba058e.png)

### 복제의 목적

1. **Scale-Out (수평적 확장)**
    - 기존 데이터 베이스 서버로만 **트래픽을 감당하기 어려운 경우 데이터 베이스를 복제**하여 트래픽 분산 처리 가능
2. **데이터 백업**
    - 데이터 백업을 기존 서버로만 감당하는 경우 실행(서비스) 중인 쿼리에 어떤 영향이 갈지 예측할 수 없다.
    - 보통 레플리카 서버를 구축하고 **데이터 백업의 용도**로 사용하기도 한다.
3. **데이터 분석**
    - 서비스 쿼리가 아닌 **분석용 쿼리를 실행**하기 위해 레플리카 서버를 두기도 한다.
4. **데이터의 지리적 분산**
    - 애플리케이션 서버와 데이터 서버의 통신 속도는 위치에 따라 차이가 있다.
    - 중간 지점(가까운 위치)에 레플리카 서버를 두어 **응답 속도 개선**

### Replication - Architecture (MySQL 8.0)

- MySQL 서버 모든 변경 사항 → **바이너리 로그 형태**로 파일에 저장
    - 바이너리 로그에 저장된 변경 정보 : Event
    - **MySQL의 복제는 바이너리 로그 기반으로 구현**

> MySQL의 복제는 바이너리 로그 기반으로 구현된다.
>

**동기화**

1. 소스 서버의 바이너리 로그 → 레플리카 서버로 전송
2. 레플리카 서버는 내용을 디스크에 저장(Relay Log) + 데이터에 반영

![Untitled](https://user-images.githubusercontent.com/84346055/284904610-11d1ef4f-487f-437e-976d-0dcf91f05a40.png)

1. **바이너리 로그 덤프 스레드**
    - 소스 서버와 레플리카 서버가 연결될때 생성
    - **바이너리 로그의 내용을 레플리카 서버로 전송**
        - 잠금이 수행
2. **레플리케이션 I/O 스레드**
    - 복제가 시작(START REPLICA) 되면 생성 , 복제가 멈추면(STOP SLAVE) 종료
    - **바이너리 로그 덤프 스레드로부터 바이너리 로그를 읽어 온다** **→ 릴레이 로그 생성**
        - 주의해야 할점 : I/O 작업만 수행한다.
3. **레플리케이션 SQL 스레드**
    - 읽어온 릴레이 로그들을 수행 → 실제 데이터 파일에 쓰는 작업을 수행
- **왜 읽어 오는 것과 쓰는 스레드가 분리되어 있나요 ?**

  읽고 → 쓰는 작업이 한 묶음이라면 복제가 완료되기 까지 오랜 시간이 걸린다.

  두 개의 스레드를 독립적으로 두어 속도와 성능 개선


## 복제 유형

> **바이너리 로그에 기록된 이벤트를 어떻게 식별하는가?**
>
1. **바이너리 로그 파일 위치** 기반 복제
2. **글로벌 트랜잭션 ID** 기반 복제

### 바이너리 로그 파일 위치 기반 복제

> 바이너리 **로그 파일명** + 파일 내에서의 위치(**Offset** , Position)로 이벤트를 식별 + 복제
>

![Untitled](https://user-images.githubusercontent.com/84346055/284904645-d3cf2f7d-5af7-49d9-a2b7-020a0f84f241.png)

**어느 소스 서버에서 왔니?**

- 복제에 참요한 MySQL 서버들은 모두 고유한 서버-id를 가져야 한다.
- server_id 값을 통해 MySQL 서버 식별
    - 기본적으로 1로 설정되는데 복제에 참여하는 서버들의 값들을 전부 고유하게 변경해야 한다.

### 문제점

- 이런 식별 방식은 **소스 서버의 값을 기준**으로 한다. (소스 서버에서만 유효하다)

![Untitled](https://user-images.githubusercontent.com/84346055/284904677-346b9a9f-b156-4af2-8043-ad5406ebe6cc.png)

> 다음과 같은 상황에서 **소스 서버를 누군가 터트렸다…..** 팀장은 급하게 기존 레플리카 1 서버를 소스 서버로 바꿨다. (승격 : Promotion)
>
- 장애 복구에 적합한 방법이 아니다
    - 복제에 참여하는 서버들은 위치를 다시 찾아야한다….
    - **동일한 이벤트가 레플리카 서버에서도 동일한 파일명과 동일한 위치에 저장될까??? 기존 위치들은 소스 서버를 바탕으로 저장된 것이기 때문에 바꿔야 한다.**

### 글로벌 트랜잭션 ID 기반 복제

> **GTID** : 서버가 속한 복제 토폴로지에서 고유한 값
>
- GTID는 소스 서버에서만 유효한 것이 아닌 복제에 참여한 모든 서버들 사이에서 고유한 값이다.
- GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자 → 소스 아이디 : 트랜잭션 아이디 값

![Untitled](https://user-images.githubusercontent.com/84346055/284904679-2c142776-e2a5-488b-9da1-293bab14cf2a.png)

### 동작 과정

![Untitled](https://user-images.githubusercontent.com/84346055/284904682-a2f337cd-1912-46a4-9e1a-d5947e0d9500.png)

- A서버를 누가 터트렸다 !!!!! , B서버를 소스 서버로 승격한다.
    - 레플리카 서버 C에서는 B에서 98번째 GTID 이후에 바이너리 로그 이벤트를 가져와 수행하면된다.

![Untitled](https://user-images.githubusercontent.com/84346055/284904687-653086c1-dbdd-4281-bb27-66f60accd361.png)

## 복제 데이터 포맷 (바이너리 로그 포맷)

> 변경 이벤트들이 바이너리 로그에 어떤 형태로 저장되는가?
>
- 레플리카 서버는 소스 서버의 바이너리 로그 이벤트를 가공하지 않고 그대로 실행한다.
1. **Statement 방식**
    - MySQL에서 실행된 SQL문을 바이너리 로그에 기록
2. **Row 방식**
    - 변경된 데이터 자체를 기록
3. **Mixed 방식**
    - 모두가 **짜장**이라 외칠 때 나는 **짬뽕**

['해물 짬뽕'으로 훈훈한 점심 시간 만든 문재인 대통령 / 비디오머그](https://youtu.be/FGOnrrxI6Gg?si=WF99U-q309L1RfeF)

### Statement

![Untitled](https://user-images.githubusercontent.com/84346055/284904692-b0a0ac56-72be-494c-93d3-30f2146b0558.png)

> MySQL에서 데이터 변경을 발생시킨 **SQL문을 바이너리 로그로 기록**
>

**장점**

1. 하나의 SQL문은 여러 개의 데이터를 변경시킬 수 있다. → 바이너리 로그 파일의 **용량을 절약 가능**하다.
2. 복제에 대해 빠른 처리 가능하다.

**단점**

1. 비확정적 쿼리의 경우 → 소스 서버와 레플리카 서버의 데이터가 달라질 수 있다.
2. Row 포맷 복제보다 데이터에 락을 더 많이 건다.
    - 특정 쿼리에 대해서 **불필요하게 많은 데이터에 오랜 시간 락을 걸 가능성**이 있다.

> Statement 포맷 방식 사용 시 트랜잭션 격리 수준이 “REPEATABLE-READ” 이상이어야 한다 !
>
- **Why?**

  Reapeatable 보다 낮은 격리 수준에서는 하나의 트랜잭션 내에서 쿼리 실행 시점마다 데이터 스냅샷이 달라질 수 있다. (소스 서버와 레플리카 서버의 데이터 불일치 발생 가능)


### Row

![Untitled](https://user-images.githubusercontent.com/84346055/284904705-a7156015-35c1-4637-a36f-4774bcd2f07e.png)

- MySQL 5.7.7 버전 부터는 Row 방식 포맷을 기본적으로 사용한다.

> **변경된 값 자체가 바이너리 로그에 기록**되는 방식이다.
>

**장점**

- 데이터 복제시 소스 서버와 레플리카 서버의 데이터를 일관되게 유지하는 가장 안전한 방식
- 락을 최소화 → 변경된 데이터가 넘어가는 거기 때문에 별도의 쿼리 실행 불필요 (락을 최소화)

**단점**

- 데이터 포맷(자료형) or 실행 쿼리에서 너무 많은 데이터가 변경된 경우
    - 바이너리 로그 파일의 크기가 **기하급수적으로 커질 수 있다.**

### MIXED

![Untitled](https://user-images.githubusercontent.com/84346055/284904717-b58e20b6-afd3-4644-bf1d-8384ac409101.png)

- 기본적으로 Statement 포맷을 사용하며 , 실행된 쿼리와 스토리지 엔진 종류에 따라 필요시 자동으로 Row 포맷으로 전환
- 즉 **비확정적 쿼리에 대해서 Row 포맷으로 변환**되서 처리

### [부록] - What is 비확정 쿼리

> from…. chatGPT
>

"비확정적 쿼리"는 주로 데이터베이스에서 특정 조건을 만족하는 데이터를 검색하는 쿼리이지만, 그 결과가 항상 일정하지 않고 시간이 지남에 따라 변경될 수 있는 쿼리를 나타냅니다. 이는 특정 시점에 데이터베이스에서 정확한 결과를 보장하지 않는 경우를 의미합니다.

데이터베이스에서 비확정적 쿼리의 일반적인 예는 다음과 같습니다:

1. **실행 시점에 따라 결과가 변하는 쿼리:** 특정 시점에는 조건을 만족하지만 시간이 지나면 더 이상 해당 조건을 만족하지 않을 수 있는 쿼리입니다. 예를 들어, "현재 주문량이 100개 이상인 모든 제품을 검색"하는 쿼리가 있을 때, 이는 실행 시점에는 만족하지만 주문이 추가되면 조건을 충족하지 않을 수 있습니다.
2. **다른 트랜잭션에 의한 변경에 영향을 받는 쿼리:** 여러 트랜잭션이 동시에 실행되고 있는 환경에서, 한 트랜잭션이 데이터를 변경할 때 다른 트랜잭션의 결과에 영향을 미칠 수 있습니다. 따라서 동일한 쿼리를 여러 번 실행하면 결과가 다를 수 있습니다.

비확정적 쿼리의 이러한 특성은 동시성 문제와 관련이 있으며, 이러한 문제를 해결하기 위해 트랜잭션과 같은 개념이 사용됩니다. 트랜잭션은 데이터베이스에서 일련의 연산을 원자적(atomic), 일관적(consistent), 고립된(isolated), 지속적인(durable) 순서로 수행하여 데이터의 일관성을 유지하도록 도와줍니다.

# 복제 동기화 방식

## 비동기 복제

- MySQL의 복제는 기본적으로 **비동기 방식**으로 동작 (5.5 부터는 반동기)
- 비동기 방식이란?
    - 소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 적용되었는지 확인 하지 않는 방식

![Untitled](https://user-images.githubusercontent.com/84346055/284904720-5819cf82-20a5-4d62-9c7e-eb220aa9e5aa.png)

### 동작 과정

1. 소스 서버에서 커밋된 트랜잭션 → 바이너리 로그 기록
2. 레플리카 서버에서는 주기적으로 바이너리 로그를 소스 서버에 요청
    - 소스 서버는 바이너리 로그를 전송

**장점**

- 빠른 성능을 보장한다.
- 소스 서버 입장에서 레플리카 서버와의 독립성이 보장된다.

**단점**

- **완벽한 데이터 동기화를 보장하지 않는다.**
    - 레플리카 서버가 데이터를 잘 받았는지 소스 서버는 확인하지 않는다… (누락이나 장애 발생 시 복구에서 문제 발생 가능)
- **When We Use?**
    - 읽기 트래픽을 분산하는 용도
    - 분석 용도

## 반동기 복제

- 비동기 복제 방식보다 좀 더 **향상된 데이터 무결성을 제공**하는 복제 동기화 방식
- 반동기 방식이란?
    - 소스 서버는 레플리카 서버가 이벤트를 전달 받음을 확인하는 방식

![Untitled](https://user-images.githubusercontent.com/84346055/284904778-1fefea00-2f31-4ded-883e-a69c143745f0.png)

### 동작 과정

1. 소스 서버가 트랜잭션 커밋 시 내용을 바이너리 로그에 기록
2. 일정 주기 마다 레플리카 서버가 소스 서버에 바이너리 로그 내용 요청
    - 레플리카 서버가 변경 이벤트를 릴레이 로그에 기록
    - 소스 서버에게 응답 메시지 전달
3. 소스 서버가 응답 메시지를 전달 받으면 해당 내용을 스토리지 엔진에 완전히 커밋

> 레플리카 서버가 소스 서버에 전달하는 응답이란 **‘전송받았음’**을 보장하는 것 , **‘적용했음’**을 보장하지는 않는다.
>

### 소스 서버는 트랜잭션 처리 중 어느 시점에 ACK를 기다릴까?

### AFTER_SYNC

- MySQL 8.0 방식 기준으로 DEFAULT
    - 아래에서 설명하겠지만 조금 **더 데이터 무결성이 강화된 방식**
- 소스 서버는 **바이너리 로그에 트랜잭션 기록하고 스토리지 엔진에 커밋하기 전**에 응답을 기다린다.

![Untitled](https://user-images.githubusercontent.com/84346055/284904788-d0a6cf96-f9ad-4771-8f81-184f928b8530.png)

### AFTER_COMMIT

- 소스 서버에서 트랜잭션을 바이너리 로그 + 스토리지 엔진에 커밋 진행 후 **클라이언트에 결과를 반환하기 전**에 응답을 기다린다.

![Untitled](https://user-images.githubusercontent.com/84346055/284904790-6816d251-064c-4a9e-a260-5cbc36738311.png)

- **Why AFTER_SYNC ?**
    1. 소스 서버에 장애 발생 시 팬텀 읽기 문제가 발생하지 않음
    2. 소스 서버의 장애 복구 처리가 더 수월하다.

### MORE

![Untitled](https://user-images.githubusercontent.com/84346055/284904793-677c78b5-3350-4c3f-b9a5-8d2e8e46e0f4.png)

> **AFTER_COMMIT**
>
- 스토리지 엔진까지 커밋이 완료되었다면? → 다른 세션에서 해당 데이터를 조회 가능
- 그 아래 **응답을 기다리는 과정에서 장애 발생 !!!!**
    - 레플리카 서버를 승격 : 어….. PHANTOM READ !!!!!

# 복제 토폴로지

> 복제의 정의 + 목적 , 바이너리 로그 포맷 , 복제 동기화 등 복제를 이해하기 위한 핵심 이론을 살펴봤다. 그런데 한가지 의문이 든다…. 복제를 어떻게 설계하지 ?
>

### 싱글 레플리카 복제 구성

> 나는 거지에요… 레플리카 서버를 많이 쓸 수 없는 환경입니다.
>

**소스 서버 1개** + **레플리카 서버 1개**

- 웹 서버는 소스 서버에만 직접 접근하여 읽기 + 쓰기 (즉 서비스 전체) 수행
- 레플리카 서버는 장애 발생 시 예비용 or 백업 용

![Untitled](https://user-images.githubusercontent.com/84346055/284904801-bb5b0f01-c051-4cc6-b86a-6afd65fe91d2.png)

### 멀티 레플리카 복제 구성

> 에이 뭐야… 나는 읽기 전용 데이터베이스 서버를 두고 싶다고 !!!!
>
- **소스 서버 1개** + **레플리카 서버 2개**
    - 레플리카 서버 1 : 데이터 백업 or 예비 용
    - 레플리카 서버 2 : 읽기 쿼리 분산 용

![Untitled](https://user-images.githubusercontent.com/84346055/284904807-a7bcbfd5-eb51-48de-8f4d-b15ca7322b29.png)

### 체인 복제 구성

> 다다익선의 원리에 나는 성능 향상을 위해 레플리카 서버를 많이 달았다…. 근데 소스 서버의 성능이 나빠졌어…
>
- 소스 서버의 성능이 나빠진 원인?
    - 소스 서버는 레플리카 서버의 요청 시 바이너리 로그를 전송해야 한다. → 1개의 소스 서버에서 M개의 전송 ?
    - 바이너리 로그 배포를 (레플리카 → 레플리카) 구조로 변경 하자
- 단점
    - 중간 계층의 레플리카 서버에 장애 발생 시 복구 복잡도가 높다.

![Untitled](https://user-images.githubusercontent.com/84346055/284904815-d33a22dc-a15f-456e-b6d3-9cc15c347b24.png)

### 듀얼 소스 복제 구성

- 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버이다.
- 웹 서버는 소스 서버와 레플리카 서버 **모두에게 읽기 + 쓰기 작업 가능**
- 데이터 정합성
    - 소스 서버와 레플리카 서버는 복제를 통해 서로의 데이터를 일치시킨다.

![Untitled](https://user-images.githubusercontent.com/84346055/284904819-d7e54309-f703-4d19-9a72-e249ad37cd4a.png)

**오류 발생 가능 상황**

1. 동일한 데이터를 각 서버에서 변경 → 쿼리의 실행 순서와 불일치하게 복제 진행 가능
2. 테이블에서 AUTO_INCREMENT 사용 시 → 중복 키 문제

### 멀티 소스 복제 구성

- 하나의 레플리카 서버가 **2개 이상의 소스 서버를 갖는 형태**

### **When We Use ?**

- 각기 다른 데이터를 하나의 서버에서 통합
- 샤딩되어 있는 테이블의 데이터를 통합
- 데이터를 모아서 하나의 서버에서 백업 수행

![Untitled](https://user-images.githubusercontent.com/84346055/284904826-385eaab9-a54a-45fb-a2f7-a7698bc2a782.png)

# 참고

[[10분 테코톡] 앤지의 DB Replication](https://www.youtube.com/watch?v=NPVJQz_YF2A)

[무뇽이와 알아보는 대규모 데이터 관리 - 데이터베이스 복제하기(리플리케이션)](https://velog.io/@backfox/무뇽이와-알아보는-대규모-데이터-관리-데이터베이스-복제하기리플리케이션-f4pota6h)
