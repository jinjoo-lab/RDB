# 데이터 베이스 튜닝 (파티셔닝)

> 데이터 베이스란 말 그대로 저장소이다. 데이터의 개수가 증가하면 결국 저장소의 크기도 증가하게 된다. 저장소의 크기가 방대해지면 서비스의 성능은 저하된다. 이러한 문제점을 해결하기 위한 방법들을 알아보자 !
>

# 데이터베이스 튜닝

# Partitioning

- 하나의 DBMS에서 크기가 큰 테이블이나 인덱스를 **파티션 단위로 나누는 것**
- 종류
    - **수직 파티셔닝 (Vertical Partitioning)**
    - **수평 파티셔닝 (Horizontal Partitioning)**

### 수직 파티셔닝 (Vertical Partitioning)

- 테이블의 컬럼을 다른 테이블로 분리하는 것이다.
    - 테이블에서 칼럼을 떼어낸다는 점에서 정규화를 떠올릴 수 있는데 정규화도 수직 파티셔닝의 일종이라 할 수 있다.
    - 다만 정규화의 목적을 넘어서 이미 정규화가 진행된 테이블에서 속성을 떼어낼 수도 있다.

Ex) 게시판

- 수직 파티셔닝의 가장 대표적인 예시인 게시판 예시이다.

![Untitled](https://user-images.githubusercontent.com/84346055/283533945-0b90d211-48b2-4aeb-9b6c-41c9ed5dd8fa.png)

> 게시판 목록의 사진을 보면 우리는 **회원 , 제목 , 시간 , 조회수**등은 확인할 수 있지만 **내용**이 직접적으로 보여지지는 않는다.
>

```
SELECT USER_ID, TITLE, CREATED_AT,VIEW FROM BOARD WHERE ;;;;
```

- **과정**

  결론을 기술하자면 데이터를 조회하는 쿼리에서 테이블의 데이터를 다 가져오고(컬럼 기준 전부 다) 거기서 일부를 추출하여 사용자에게 반환하는 것이다.

  결국 **I/O 작업의 관점**에서 본다면 가장 큰 용량의 게시글 내용을 사용하지도 않는데 가져 온다면 성능 측면에서 아쉽다…..

  이럴 때 사용하는 것이 수직 파티셔닝이다.


**Before**

| BOARD_ID | USER_ID | TITLE | CREATED_AT | VIEW | CONTENT |
| --- | --- | --- | --- | --- | --- |
|  |  |  |  |  |  |

**After**

- CONTENT 칼럼을 분리하여 별도의 테이블로 구성한다면 게시글 목록을 반환하는 작업(쿼리)가 가벼워질 것이다.
- 그리고 전체 데이터를 가져와야 하는 경우 **JOIN 연산을 수행**하면 된다.

| BOARD_ID | TITLE | CREATED_AT | VIEW |
| --- | --- | --- | --- |
|  |  |  |  |

| BOARD_ID | CONTENT |
| --- | --- |
|  |  |

### 수평 파티셔닝 (Horizontal Partitioning)

- 테이블의 로우 단위로 분리하는 것이다.
    - 테이블의 스키마가 변경되는 것은 아니다 !
- 위에서 분리한 게시글 목록 테이블에 데이터가 너무 많다고 가정한다면 행을 기준으로 분리하는 것이다 !

| BOARD_ID | TITLE | CREATED_AT | VIEW |
| --- | --- | --- | --- |
|  |  |  |  |

| BOARD_ID | TITLE | CREATED_AT | VIEW |
| --- | --- | --- | --- |
|  |  |  |  |

![Untitled](https://user-images.githubusercontent.com/84346055/283533980-97ff8759-ac3b-4558-96ed-8a50689927cb.png)

- **샤딩과 수평 파티셔닝의 차이점**

  수평 파티셔닝은 물리적으로 같은 DB내 위치 , 샤딩은 물리적으로 다른 DB내에 위치하는 것이다. 즉 **로우 단위로 분리된 테이블이 같은 데이터 베이스에 위치하는가**로 구분할 수 있다.


### 파티셔닝 장점

1. **가용성 (Availability)**
    - 시스템이 중단 되지 않고 지속적으로 운영될 수 있는 능력
2. **관리용이성 (Manageability)**
    - 테이블의 크기가 줄어들어 관리가 쉬어진다.
        - 파티션 단위의 백업 , 추가 , 삭제 , 변경 (파티션이 테이블보다는 단위가 작겠죠????)
3. **성능 (Performance)**
    - 특정 DML과 Query의 성능이 향상된다.
        - 특히 탐색에 있어 부하를 줄일 수 있다.
    - 대용량 Data Write 할 때 효율적이다.
        - insert 작업들을 파티션으로 분산시켜 경합을 줄인다.

### 파티셔닝 단점

1. 분할된 파티션에 대해 연산을 따로 수행해야 한다.
    - 수직의 경우 JOIN 연산으로 테이블의 데이터를 합쳐줘야 한다.
    - 수평의 경우 데이터를 찾기 위해 여러 파티션을 찾아야 할 수 있다.
2. **인덱스의 경우 각 파티션 별로 걸어줘야 한다 !**
3. 데이터 무결성을 해칠 수 있다.

# 파티셔닝 방식

- 파티셔닝에서는 각 데이터를 균등하게 나누는 것 (파티션에 배정하는 것)이 가장 중요하다.
- 이러한 파티셔닝 분할에는 크게 3가지 방식이 있다.

![Untitled](https://user-images.githubusercontent.com/84346055/283533993-e9bb396a-fb7a-4d58-8e07-069b746d7794.png)

## 목록(List) 분할

- 특정 Partition에 저장될 데이터에 대한 명시적 제어
    - 즉 column 값에 대한 파티셔닝
    - multi-column partition key는 구현이 어렵기 때문에 단일 column으로 파티셔닝

### 장점

- 명시적 제어 가능
- 분포도가 비슷하여 column 조건이 자주 사용되는 경우 유용하다.

### 단점

- 단일 컬럼 제어의 한계가 생기는 경우

## 범위(Range) 분할

- 분할 기준(분할 키) 값이 범위 내에 있는지 여부로 판단한다.
    - 가장 많이 사용하는 분할 키 : **시간(날짜)**
    - 입력된 데이터의 분할 키가 특정 범위에 만족한다면 해당 파티션으로 이동한다.

### 장점

- 쉬운 관리 기법
- 관리 시간이 단축된다.

### 단점

- 범위라는 것의 제약 특성 상 특정 파티션에 데이터가 몰릴 수 있다.

## 해시(Hash) 분할

- 파티션 키 (분할 키)에 대하여 Hash 함수 수행하여 파티셔닝

### 장점

- 균등한 데이터 분할 가능
- 질의 성능 향상 : Select 시 조건과 무관하게 **병렬 처리 가능**

### 단점

- 특정 데이터의 hash partition 판단 불가
- 범위성 데이터에 대해서는 사용하기 어렵다. → 해시 함수의 특성
