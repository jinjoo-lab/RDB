# 데이터베이스 데드락

# 교착 상태 ( DeadLock )

- 데이터 베이스에서 비관적 락을 사용하는 경우 데이터베이스의 락 연산을 사용한다. 하지만 락 연산을 사용하는 경우 교착 상태에 대한 이해가 필요하다 !

> 데이터베이스에서의 교착 상태란 둘 이상의 트랜잭션이 서로가 잠금을 포기하기를 기다리는 상황
>

![Untitled](https://user-images.githubusercontent.com/84346055/282234109-487015d0-f0da-44fa-aa11-548146168132.png)

- Ex)
    - USER_1이 order(S) - car(E) 테이블 순서대로 접근
    - USER_2가 car(S) - order(E) 테이블 순서대로 접근
- **문제 !**

  USER_1과 USER_2 전부 상대방이 건 락을 해제하기 전까지 다음 작업이 불가능하다. (결과적으로 두 트랜잭션 모두 영구 대기 상태에 들어간다)


# 해결 전략

1. 교착 상태 예방
2. 교착 상태 회피
3. 교착상태 탐지 / 회복
4. 낙관적 병행 제어
5. 빈도 줄이기

## 교착상태 예방

> 최대한 교착 상태가 일어나지 않도록 방지하는 것 !
>
1. 각 트랜잭션이 실행되기 전 **필요한 데이터를 모두 잠금(Locking)**
    - 하지만 해당 방법을 사용할 경우 트랜잭션의 병행성을 굉장히 낮추기 때문에 동시성 처리의 개념과는 맞지 않는다.
    - 몇몇 트랜잭션은 계속해서 처리되지 못하여 **기아 상태**에 빠질 수 있다.
2. SET_LOCK_TIMEOUT
    - 교착 상태인 데이터가 있다면 일정 시간이 지나면 해당 **데이터에 대한 쿼리를 취소**한다.
    - **근본적인 해결책은 될 수 없다 !**

## 교착상태 회피

> **Time Stamp**를 활용하여 교착상태가 일어나지 않도록 회피하는 방법
>
- T1 , T2 , T3
    - 타임스탬프가 더 작다 : 더 먼저 시작된 트랙잭션 (우선순위가 더 높다)
    - 타임스탬프가 더 크다 : 더 늦게 시작된 트랜잭션 (우선순위가 더 낮다)

### Wait-Die

- 교착상태 회피를 위한 비선점 기법
    - 우선순위가 높은 트랜잭션의 대기 허용
    - 다른 트랜잭션이 데이터를 점유하고 있을때 **대기하거나 롤백**
- **→ : 상대방이 점유한 데이터를 요청**
    - T1 → T2 (T1이 더 먼저 들어온 트랜잭션)
        - T1은 대기 상태
    - T3 → T2 (T2가 더 먼저 들어온 트랜잭션)
        - T3는 롤백후 복귀

**장점**

- **데이터의 일관성 보장**

**단점**

- **기아 상태 발생 가능**
- **트랜잭션의 롤백 비용**

![Untitled](https://user-images.githubusercontent.com/84346055/282234115-8ee257fc-4706-4e10-83c4-a3e19de012ea.png)

### Wound-Wait

- 교착상태 회피를 위한 선점 기법
    - 우선순위가 높은 트랜잭션에게 선점 허용
    - 다른 트랜잭션이 데이터를 점유하고 있을 때 **빼앗거나 대기**
- **→ : 상대방이 점유한 데이터를 요청**
    - T1 → T2 (T1이 더 먼저 들어온 트랜잭션)
        - T1이 데이터를 선점한다. T2는 롤백후 복귀
    - T3 → T2 (T2가 더 먼저 들어온 트랜잭션)
        - T3은 대기 상태

장점

- **기아 상태 방지 가능**

단점

- **데이터 불일치 가능성**

![Untitled](https://user-images.githubusercontent.com/84346055/282234116-35ae75f6-a6bd-4061-8447-4f00acf601a2.png)

- **뭐가 더 좋나요?**

  굉장히 애매한 질문이다. 결국 해당 시스템에서 **선점이나 비선점**이나에 따라서 선택적 문제가 있다는 것이다.


## 교착상태 탐지

> 현재 트랜잭션들 사이에 교착상태가 발생하였는지 탐지하고 교착상태를 제거하여 회복하는 방법
>
- **교착상태 탐지 기법 - ( Union - Find )**
    - 대기 그래프 구성 → **사이클의 존재 유무**로 교착 상태 탐지 ( Union - Find )
    - 교착상태는 철회할 **희생자 선택**하여 해결
- 교착상태 회복
    - 교착상태를 일으킨 트랜잭션을 강제 종료
        - 모두 중지
        - 한 개씩 중지
    - 자원 선점 : 교착 상태의 트랜잭션의 데이터를 다른 프로세스에게 할당하여 대기 시킨다.

## 낙관적 병행 제어 기법

- 트랜잭션이 실행되는 동안에는 아무런 검사 없이 다 실행된 이후 검사하여 문제가 있다면 롤백

## 빈도 낮추기

- 트랜잭션의 커밋 빈도 높이기
- 테이블 단위로 잠금
- 고립 수준 낮추기
- 정해진 순서로 테이블 접근
    - A → B , B → A 로직 동시 존재 불가능하도록 설계 및 구현
